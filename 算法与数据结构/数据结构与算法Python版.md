数据结构与算法Python版 https://www.bilibili.com/video/BV1h7411m7BK?p=8
原视频来源   https://www.icourse163.org/course/0809PKU068-1206307812
# 0 算法的时间复杂度与空间复杂度分析 
## 时间复杂度 -> Big O Notation
    - 常数 1
    - 对数 log(n)
    - 线性 n
    - 对数线性 n * log(n)
    - 平方 n^2
    - 立方 n^3
    - 指数 2^n
    - 阶乘 n! 比 指数 2^n 还耗时间
- 时间与空间的复杂度需要一个平衡与取舍

# 0.1 python基础数据类型的性能
    - list与dict对比的操作：
                   list                             dict     
        索引      自然数i                          不可变类型值key
        添加      append, extend, insert          b[k] = v
        删除      pop, remove                     pop
        更新      a[i] = v                        b[k] = v
        正查      a[i], a[i: j]                   b[k], copy
        反查      index[v], count(v)              无
        其他      reverse, sort                   has_key, update
### list列表 -> 执行时间随着列表的规模增大而线性上升
    - 四种生成前N个整数列表的方法
        * 循环列表连接： （运行速度最慢）
                a = []
                for i in range(1000):
                    a = a + [i]
        * append追加元素：（运行速度一般）
                a = []
                for i in range(1000):
                    a = a.append(i)
        * 列表推导式：（运行速度较快）
                a = [i for i in range(1000)]
        * range函数转列表：（运行速度最快）
                a = list(range(1000))
### dict字典 -> 执行时间与规模无关，是常数

# 1 线性结构：栈stack，队列queue，双端队列deque，列表list
## 什么是线性结构
    - 线性结构定义：一种有序数据项的集合，其中每个数据都有唯一的前驱和后继（第一个没有前驱，最后一个没有后继）
    - 不同的线性结构的区别在于数据项的增减方式
## 3.1 栈stack ->代码实现> myStack.py
    - 只在栈顶进行添加移除操作，（后进先出LIFO）
    - 栈的应用：反转次序：浏览器回退操作，最先back的是刚刚访问的网页，再一步一步向后退。；进制转换
    - 栈的常见操作：
        Stack(): 创建空栈
        push(item): 添加元素item
        pop(): 移除栈顶元素，并返回，修改原栈
        peek(): 查看栈顶元素，并返回，不修改原栈
        isEmpty(): 判断栈是否为空
        size(): 返回栈中元素个数
## 3.2 队列queue ->代码实现> myQueue.py
    - 队列是一种有次序的数据集合，新数据在队尾加入，移除数据总是在队首移除（先进先出FIFO）
    - 队列的应用：打印机打印任务；计算机中进程调度；键盘缓冲
## 3.3 双端队列deque ->代码实现> myDeque.py
    - 数据从两端都可以添加与删除

# 2 递归recrusion 
    - 把某个问题分解成规模更小的相同问题，然后在算法中调用自身来完成。
    - 递归三定律：
        * 必须有一个最基本的结束条件 -> 最小规模问题的直接解决
        * 必须能改变状态向基本条件演进 -> 减小问题规模
        * 必须调用自身 -> 解决减小了规模的相同问题
## 递归可视化 
    - python内置的turtle海龟作图系统
        - 意象是模拟海龟在沙滩上爬行而留下的足迹
            forward(n); backward(n)  # 用来爬行：划线
            left(a); right(a)  # 用来转向：旋转一定角度
            penup(); pendown()   # 抬笔，放笔
            pensize(s); pencolor(c)  # 笔属性：划的线的一些属性设置
### 分形fractal树: 
    - 整体与部分是相似的，自相似：如雪花，树，云朵，山脉，海岸线
## 分治策略：分而治之
    - 大问题分解成小问题，并把结果汇总成原问题的解
## 优化问题和贪心策略
- 优化问题：找到问题的最优解
- 找零兑换问题（用最少的硬币数量来找零）：
    * 贪心策略解决找零兑换问题：尽量以最大面值返回：例如：63 = 25*2 + 10*1 + 1*3 
        ** 可以解决但不一定会是最优解 例 假如有21分面值的硬币：则最优解为：63 = 21*3
    * 递归解法：对每个硬币面值进行一个尝试，然后选择数量最小的那个
        ** 问题：极其低效
        ** 改进：保存中间计算的结果，消除重复计算
    * 动态规划解法：从最简单的 一分钱找零 开始，逐步递加上去，设法保证每一分钱的递加都是最优解
        ** 主要思想：从最简单的情况开始到达所需找零的循环，其每一步都依靠以前的最优解来得到本步骤的最优解，直到得到答案
    

# 3 排序与查找
    - 查找算法：顺序查找，二分查找
    - 排序算法：冒泡排序，选择排序，插入排序，希尔排序，归并排序，快速排序
    - 散列 hashing: 把查找的次数降到常数级别 -> （由数据项的值，来确定存放的位置）
        * 构造新的数据结构，使得查找复杂度降到 O(1)，的概念叫 散列。
        * 散列函数：实现从数据项到存储槽名称的转换的函数。
            ** 常用的散列方法：求余数，数据项除以散列表的大小得到的余数作为槽号，就可以把数据项存入到对应的槽中。
                例： h(item) = item % 11
                    item       : 54  26  93  17  77  31
                    hash value : 10   4   5   6   0   9
            ** 槽被数据项占据的比例 称为 散列表的负载因子，这里总共占了6个槽，而总槽为0～10，则 负载因子为 6/11，
                    负载因子越小越好（lambda在0～1之间最好）
            ** 此时查找元素只需在对应的散列后的槽中查找即可。
            ** 散列冲突 collision：多个元素分到一个槽中去了。
                方法一：开放寻址open addressing: 一个槽里多余的元素，出去寻找空槽来存放。
                    线性探测：这种数据的查找，就是先到那个槽里看，没有就往后找（逐个查找或者跳跃查找+3这样子），到尾部没有，则从首部开始找
                方法二：再散列
                技巧：把散列表的大小设为素数，如 11
        * 好的散列函数的特性：冲突最少，计算开销低（额外计算小），充分分散数据项（节约空间）
        * 近似完美的散列函数：MD5 和 SHA 系列函数
        * 用途：用于数据的一致性校验（为每个文件计算散列值，仅对比散列值即可得知文件内容是否相同）-> 用于网络文件下载完整性校验：
            ** 特性：
                压缩性：任意长度的数据，得到的 '指纹'长度固定。
                易计算性：从原数据计算 '指纹'容易，但从指纹几乎不可能计算出原数据
                抗修改性：对原数据的微小改动，都会引起 '指纹'的大改变
                抗冲突性：已知原数据和 '指纹'，要找到相同指纹的数据（伪造）很困难
    - 区块链技术 block chain <- 散列函数最酷的应用：
        * 是一种分布式数据库，每个节点都保存了整个数据库的所有数据，任何地点存入的数据都会完成同步。
        * 最本质的特征：去中心化。不存在任何控制中心和协调节点，所有节点都是平等的，无法被控制。
        * 区块链：由一个个区块block组成，区块分为头head和体body。
            ** 头：记录元数据和链接到前一个区块的信息：生成时间，前一个区块（head+body）的散列值。
            ** 体：区块体记录了实际数据

    

# 4 树
- 一种非线性结构：树
- 树的定义：有唯一的根结点，每个节点从根结点开始的路径都是唯一的。如果树的每个节点最多有两个子节点，就是二叉树。





# 5 图




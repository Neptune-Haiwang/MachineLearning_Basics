数据结构与算法Python版 https://www.bilibili.com/video/BV1h7411m7BK?p=8
    //原视频来源   https://www.icourse163.org/course/0809PKU068-1206307812
# python正则表达式

    

# 0 算法的时间复杂度与空间复杂度分析 
## 时间复杂度 -> Big O Notation
    - 常数 1
    - 对数 log(n)
    - 线性 n
    - 对数线性 n * log(n)
    - 平方 n^2
    - 立方 n^3
    - 指数 2^n
    - 阶乘 n! 比 指数 2^n 还耗时间
- 时间与空间的复杂度需要一个平衡与取舍

# 0.1 python基础数据类型的性能
    - list与dict对比的操作：
                   list                             dict     
        索引      自然数i                          不可变类型值key
        添加      append, extend, insert          b[k] = v
        删除      pop, remove                     pop
        更新      a[i] = v                        b[k] = v
        正查      a[i], a[i: j]                   b[k], copy
        反查      index[v], count(v)              无
        其他      reverse, sort                   has_key, update
### list列表 -> 执行时间随着列表的规模增大而线性上升
    - 四种生成前N个整数列表的方法
        * 循环列表连接： （运行速度最慢）
                a = []
                for i in range(1000):
                    a = a + [i]
        * append追加元素：（运行速度一般）
                a = []
                for i in range(1000):
                    a = a.append(i)
        * 列表推导式：（运行速度较快）
                a = [i for i in range(1000)]
        * range函数转列表：（运行速度最快）
                a = list(range(1000))
### dict字典 -> 执行时间与规模无关，是常数

# 1 线性结构：栈stack，队列queue，双端队列deque，列表list
## 什么是线性结构
    - 线性结构定义：一种有序数据项的集合，其中每个数据都有唯一的前驱和后继（第一个没有前驱，最后一个没有后继）
    - 不同的线性结构的区别在于数据项的增减方式
## 3.1 栈stack ->代码实现> myStack.py
    - 只在栈顶进行添加移除操作，（后进先出LIFO）
    - 栈的应用：反转次序：浏览器回退操作，最先back的是刚刚访问的网页，再一步一步向后退。；进制转换
    - 栈的常见操作：
        Stack(): 创建空栈
        push(item): 添加元素item
        pop(): 移除栈顶元素，并返回，修改原栈
        peek(): 查看栈顶元素，并返回，不修改原栈
        isEmpty(): 判断栈是否为空
        size(): 返回栈中元素个数
## 3.2 队列queue ->代码实现> myQueue.py
    - 队列是一种有次序的数据集合，新数据在队尾加入，移除数据总是在队首移除（先进先出FIFO）
    - 队列的应用：打印机打印任务；计算机中进程调度；键盘缓冲
## 3.3 双端队列deque ->代码实现> myDeque.py
    - 数据从两端都可以添加与删除

# 2 递归recrusion 
    - 把某个问题分解成规模更小的相同问题，然后在算法中调用自身来完成。
    - 递归三定律：
        * 必须有一个最基本的结束条件 -> 最小规模问题的直接解决
        * 必须能改变状态向基本条件演进 -> 减小问题规模
        * 必须调用自身 -> 解决减小了规模的相同问题
## 递归可视化 
    - python内置的turtle海龟作图系统
        - 意象是模拟海龟在沙滩上爬行而留下的足迹
            forward(n); backward(n)  # 用来爬行：划线
            left(a); right(a)  # 用来转向：旋转一定角度
            penup(); pendown()   # 抬笔，放笔
            pensize(s); pencolor(c)  # 笔属性：划的线的一些属性设置
### 分形fractal树: 
    - 整体与部分是相似的，自相似：如雪花，树，云朵，山脉，海岸线
## 分治策略：分而治之
    - 大问题分解成小问题，并把结果汇总成原问题的解
## 优化问题和贪心策略
- 优化问题：找到问题的最优解
- 找零兑换问题（用最少的硬币数量来找零）：
    * 贪心策略解决找零兑换问题：尽量以最大面值返回：例如：63 = 25*2 + 10*1 + 1*3 
        ** 可以解决但不一定会是最优解 例 假如有21分面值的硬币：则最优解为：63 = 21*3
    * 递归解法：对每个硬币面值进行一个尝试，然后选择数量最小的那个
        ** 问题：极其低效
        ** 改进：保存中间计算的结果，消除重复计算
    * 动态规划解法：从最简单的 一分钱找零 开始，逐步递加上去，设法保证每一分钱的递加都是最优解
        ** 主要思想：从最简单的情况开始到达所需找零的循环，其每一步都依靠以前的最优解来得到本步骤的最优解，直到得到答案
    

# 3 排序与查找
    - 查找算法：顺序查找，二分查找
    - 排序算法：冒泡排序，选择排序，插入排序，希尔排序，归并排序，快速排序
    - 散列 hashing: 把查找的次数降到常数级别 -> （由数据项的值，来确定存放的位置）
        * 构造新的数据结构，使得查找复杂度降到 O(1)，的概念叫 散列。
        * 散列函数：实现从数据项到存储槽名称的转换的函数。
            ** 常用的散列方法：求余数，数据项除以散列表的大小得到的余数作为槽号，就可以把数据项存入到对应的槽中。
                例： h(item) = item % 11
                    item       : 54  26  93  17  77  31
                    hash value : 10   4   5   6   0   9
            ** 槽被数据项占据的比例 称为 散列表的负载因子，这里总共占了6个槽，而总槽为0～10，则 负载因子为 6/11，
                    负载因子越小越好（lambda在0～1之间最好）
            ** 此时查找元素只需在对应的散列后的槽中查找即可。
            ** 散列冲突 collision：多个元素分到一个槽中去了。
                方法一：开放寻址open addressing: 一个槽里多余的元素，出去寻找空槽来存放。
                    线性探测：这种数据的查找，就是先到那个槽里看，没有就往后找（逐个查找或者跳跃查找+3这样子），到尾部没有，则从首部开始找
                方法二：再散列
                技巧：把散列表的大小设为素数，如 11
        * 好的散列函数的特性：冲突最少，计算开销低（额外计算小），充分分散数据项（节约空间）
        * 近似完美的散列函数：MD5 和 SHA 系列函数
        * 用途：用于数据的一致性校验（为每个文件计算散列值，仅对比散列值即可得知文件内容是否相同）-> 用于网络文件下载完整性校验：
            ** 特性：
                压缩性：任意长度的数据，得到的 '指纹'长度固定。
                易计算性：从原数据计算 '指纹'容易，但从指纹几乎不可能计算出原数据
                抗修改性：对原数据的微小改动，都会引起 '指纹'的大改变
                抗冲突性：已知原数据和 '指纹'，要找到相同指纹的数据（伪造）很困难
    - 区块链技术 block chain <- 散列函数最酷的应用：
        * 是一种分布式数据库，每个节点都保存了整个数据库的所有数据，任何地点存入的数据都会完成同步。
        * 最本质的特征：去中心化。不存在任何控制中心和协调节点，所有节点都是平等的，无法被控制。
        * 区块链：由一个个区块block组成，区块分为头head和体body。
            ** 头：记录元数据和链接到前一个区块的信息：生成时间，前一个区块（head+body）的散列值。
            ** 体：区块体记录了实际数据

    

# 4 树
    - 一种非线性结构：树
    - 树的定义：有唯一的根结点，每个节点从根结点开始的路径都是唯一的。如果树的每个节点最多有两个子节点，就是二叉树。
    - 树的应用：解析树：句子语法分析：（主谓宾定状补），
        * 表达式解析：叶节点保存操作数，内部节点保存操作符。表达式越底层，优先级越高。
            ** 例（全括号表达式）： ((7  + 3) * (5 - 2))
                                        *
                                +               -
                            7       3       5        2                     
            ** 树中的每个子树都表示一个一个子表达式。将子树替换为子表达式值的节点，即可实现求值。
    - 树的遍历：
        * 前序遍历 preorder：根左右
        * 中序遍历 inorder：左根右
        * 后序遍历 postorder：左右根
    - 优先队列（VIP用户优先入队出队）与二叉堆：
        * 二叉堆实现优先队列，可以使得优先队列的入队和出队复杂度都保持在 O(log n)， 对数复杂度 -> 二叉树实现
        * 最小 KEY 排在队首的叫 最小堆 min heap； 最大KEY排在队首的叫　最大堆 max heap
        * 完全二叉树特性：
            ** 某节点下标为p, 则其左子节点下标为2p，右子节点下标为2p+1，其父节点下标为p//2
        * 堆次序 heap order:
            ** 任何一个节点x，其父节点p中的key均小于x中的key，这样符合'堆'性质的二叉树，其中任何一条路径，均是一个已排序数列，根结点的key最小。
    - 二叉查找树 binary search tree：
        * 性质：比父节点小的key都出现在左子树，比父节点大的key都出现在右子树。
    - AVL树：AVL是发明者名字的缩写
        * AVL树能够在KEY插入时始终保持平衡的二叉查找树，
            ** 实现：对每个节点增加平衡因子参数（即根据左右子树的高度差，如果高度差为0，则称作平衡。）
            ** 把树的所有节点的平衡因子都变成0。
        * AVL树最差情况下的性能：即平衡因子为1或-1， 此时AVL树的搜索复杂度为 O(log n)
            ** 斐波那契数列   
        * 重新平衡：将不平衡的子树进行旋转rotation
    - ADT Map 实现方法的时间复杂度小结：
                有序表        散列表          二叉查找树BST         AVL树    
        put     O(1)        O(1) -> O(n)    O(log n) -> O(n)    O(log n)
        get     O(log n)    O(1) -> O(n)    O(log n) -> O(n)    O(log n)
        in      O(log n)    O(1) -> O(n)    O(log n) -> O(n)    O(log n)
        del     O(n)        O(1) -> O(n)    O(log n) -> O(n)    O(log n)

# 5 图
## 各种图画的英文的中文解释
    painting: 用画刷笔画的油画
    drawing: 用硬笔画的素描画/线条画
    picture: 真实形象所反映的画，如照片，take picture
    image: 由印象而来的画，遥感印象，传感器传来的印象画
    figure: 轮廓图，figure out
    diagram: 抽象的概念关系图，如电路图，大气洋流图
    chart: 由数字统计而来的柱状图，折线图等; map地图, plot地图上的一小块
    graph: 重在由一些基本元素构造而来的图，如点和线段等。

## 图的概念
    - 图graph：由节点和边构成，（树也是一种具有特殊性质的图）
        * 顶点vertex：也叫节点node，顶点具有名称标示key，也可以携带数据项payload
        * 边edge：连接两个顶点，有向，无向
        * 权重weight：从一个顶点到另一个顶点的代价，例如：公交网络中两个站点之间的距离，通行时间，票价等权重。
    - G = (V, E), E中的每条边 e = (v, w), v 和 w 都是V中的顶点。赋权图增加子集 例：E = {(v0,v1,5), (v5,v2,1),...}
    - 路径path：例：(v3, v4, v0, v1), 其边为：{(v3,v4,7), (v4,v0,1),(v0,v1,5)}
    - 圈cycle：例（v5, v2, v3, v5）
        * 如果一个有向图中不存在任何圈，则称为 有向无圈图 DAG: directed acyclic graph
## 抽象数据类型 ADT graph:
    - ADT graph实现的两种形式：
        * 邻接矩阵：adjacency matrix: 没有连接权重为0， 有权重则赋予相应的权重。但是这种矩阵是稀疏矩阵
        * 邻接表：adjacency list：维护一个包含所有顶点的主列表，主列表中每个顶点，再关联一个与自身有边连接的所有顶点的列表。
            ** 例：V0 : id = 'V0', adj = {V1:5, V5:2}
    - 最小权重的生成树 minimum weight spanning tree：
        * 对于图G(V, E)的最小生成树T, 定义为：包含所有顶点V, 以及E的无圈子集，并且边的权重之和最小。
        * 应用：信息广播：每个路由器节点都可以遍历到，同时总费用最小。
        * 最小生成树算法：贪心算法，每一步都沿着最小权重的边向前搜索。

